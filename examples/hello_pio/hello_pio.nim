import picostdlib/[gpio, pio, time]

{.push header: "hello.pio.h".}
# Import program and config the C header file that is generated  at
# compile-time.
let helloProgram {.importc: "hello_program".}: PioProgram

proc helloProgramGetDefaultConfig(offset: uint): PioSmConfig
  {.importc: "hello_program_get_default_config".}
{.pop.}

proc initPioHelloProgram(pio: PioInstance, sm: PioStateMachine, offset: uint, pin: Gpio) =
  # Prepare the PIO state machine to run our blinky program

  # Get a PioStateMachineConfig object which represents the default config,
  # as generated by PIOASM at compile time.
  var cfg = helloProgramGetDefaultConfig(offset)

  # Set GPIO pin to be used as output by the program
  cfg.setOutPin(pin)

  # Set GPIO function to be used by the PIO
  pio.gpioInit(pin)

  # Configure the pin as output
  pio.setPinDirs(sm, Out, {pin})

  # Initialize and enable the state machine, which starts running the program
  pio.init(sm, offset, cfg)
  pio.enable sm

let
  # Can run on either pio0 or pio1 instance, here we choose pio0
  helloPioInst = pio0

  # Load the program into the PIO instance's program memory and receive
  # the memory offset of where it was stored. This will be used to start
  # the program.
  offset = helloPioInst.addProgram(helloProgram)

  # Find an unused state machine within the PIO instance and return it's
  # ID (0..3). Returns -1 if no SM is free. Also claims the SM as used.
  smResult = helloPioInst.claimUnusedSm(false)

if smResult >= 0:
  let sm = smResult.PioStateMachine

  # Prepare for running our PIO program, using the onboard LED pin as output
  initPioHelloProgram(helloPioInst, sm, offset, DefaultLedPin)

  while true:
    # Push some data to the PIO output FIFO to make the LED blink
    helloPioInst.putBlocking(sm, 1)
    sleep 500  
    helloPioInst.putBlocking(sm, 0)
    sleep 500  
